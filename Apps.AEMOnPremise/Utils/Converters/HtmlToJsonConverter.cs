using Blackbird.Applications.Sdk.Common.Exceptions;
using HtmlAgilityPack;
using Newtonsoft.Json.Linq;
using System.Web;
using Apps.AEMOnPremise.Models.Entities;

namespace Apps.AEMOnPremise.Utils.Converters;

public static class HtmlToJsonConverter
{
    public static string ExtractSourcePath(string metadata)
    {
        var doc = new HtmlDocument();
        doc.LoadHtml(metadata);

        var metaNode = doc.DocumentNode.SelectSingleNode("//meta[@name='blackbird-source-path']");
        if (metaNode != null)
        {
            string sourcePath = metaNode.GetAttributeValue("content", string.Empty);
            if (!string.IsNullOrEmpty(sourcePath))
            {
                return sourcePath;
            }
        }

        throw new PluginApplicationException("HTML does not contain a valid source path meta tag. Make sure the HTML is generated by the connector.");
    }

    public static List<JsonContentEntity> ConvertToJson(string html)
    {
        var doc = new HtmlDocument();
        doc.LoadHtml(html);

        var bodyNode = doc.DocumentNode.SelectSingleNode("//body");
        if (bodyNode == null)
        {
            throw new ArgumentException("HTML does not contain a body element");
        }

        var contentDivs = bodyNode.SelectNodes("./div");
        if (contentDivs == null || contentDivs.Count == 0)
        {
            throw new ArgumentException("HTML body does not contain any content divs");
        }

        var resultEntities = new List<JsonContentEntity>();

        foreach (var div in contentDivs)
        {
            var originalJsonEncoded = div.GetAttributeValue("data-original-json", null);
            if (string.IsNullOrEmpty(originalJsonEncoded))
            {
                continue;
            }

            var originalJsonString = HttpUtility.HtmlDecode(originalJsonEncoded);
            var jsonObj = JObject.Parse(originalJsonString);
            
            // Extract and remove references
            var references = ExtractReferences(jsonObj);
            
            // Process div based on its type (root or reference)
            var isRoot = div.GetAttributeValue("data-root", "").ToLower() == "true";
            var referencePath = div.GetAttributeValue("data-reference-path", null);
            var sourcePath = div.GetAttributeValue("data-source-path", null);
            
            // If neither root nor reference, skip
            if (!isRoot && string.IsNullOrEmpty(referencePath))
            {
                continue;
            }

            // Update JSON values based on elements with data-json-path
            var elementsWithPath = div.SelectNodes(".//*[@data-json-path]");
            if (elementsWithPath != null)
            {
                foreach (var element in elementsWithPath)
                {
                    var jsonPath = element.GetAttributeValue("data-json-path", null);
                    if (string.IsNullOrEmpty(jsonPath))
                    {
                        continue;
                    }

                    // For reference content, remove "references." prefix from JSON paths
                    if (!isRoot && !string.IsNullOrEmpty(referencePath) && 
                        jsonPath.StartsWith("references.", StringComparison.OrdinalIgnoreCase))
                    {
                        jsonPath = jsonPath.Substring("references.".Length);
                    }

                    if (IsRichTextPath(jsonPath) && element.Name != "span")
                    {
                        var cleanElement = element.CloneNode(true);
                        cleanElement.Attributes.Remove("data-json-path");
                        UpdateJsonValue(jsonObj, jsonPath, cleanElement.OuterHtml);
                    }
                    else
                    {
                        UpdateJsonValue(jsonObj, jsonPath, element.InnerHtml);
                    }
                }
            }

            // Add to result as root or reference content entity
            resultEntities.Add(new JsonContentEntity(
                sourcePath: isRoot ? sourcePath : referencePath,
                targetContent: jsonObj,
                references: references,
                referenceContent: !isRoot
            ));
        }

        // Ensure at least one entity was found
        if (resultEntities.Count == 0)
        {
            throw new ArgumentException("No valid content entities found in HTML");
        }

        return resultEntities;
    }

    private static List<ReferenceEntity> ExtractReferences(JObject jsonObj)
    {
        var references = new List<ReferenceEntity>();
        
        // Check if references property exists
        if (jsonObj.TryGetValue("references", out var refsToken) && refsToken is JArray refsArray)
        {
            foreach (var refToken in refsArray)
            {
                if (refToken is JObject refObj)
                {
                    string? referencePath = refObj["referencePath"]?.ToString();
                    string? content = refObj["content"]?.ToString();
                    string? propertyName = refObj["propertyName"]?.ToString();
                    string? propertyPath = refObj["propertyPath"]?.ToString();
                    
                    if (!string.IsNullOrEmpty(referencePath))
                    {
                        references.Add(new ReferenceEntity(referencePath, content ?? string.Empty, propertyName, propertyPath));
                    }
                }
            }
            
            // Remove references property from the JSON object
            jsonObj.Remove("references");
        }
        
        return references;
    }

    private static bool IsRichTextPath(string path)
    {
        return path.EndsWith(".text", StringComparison.OrdinalIgnoreCase);
    }

    private static void UpdateJsonValue(JObject jsonObj, string path, string value)
    {
        var pathSegments = SplitJsonPath(path);
        JToken current = jsonObj;

        for (int i = 0; i < pathSegments.Length - 1; i++)
        {
            string segment = pathSegments[i];
            
            if (segment.Contains("[") && segment.EndsWith("]"))
            {
                int indexStart = segment.IndexOf("[");
                string propertyName = segment.Substring(0, indexStart);
                int arrayIndex = int.Parse(segment.Substring(indexStart + 1, segment.Length - indexStart - 2));
                
                if (current![propertyName] == null)
                {
                    current[propertyName] = new JArray();
                }
                
                var array = (JArray)current[propertyName]!;
                while (array.Count <= arrayIndex)
                {
                    array.Add(new JObject());
                }
                
                current = array[arrayIndex];
            }
            else
            {
                if (current![segment] == null)
                {
                    current[segment] = new JObject();
                }
                
                current = current[segment]!;
            }
        }

        string lastSegment = pathSegments[pathSegments.Length - 1];
        
        if (lastSegment.Contains("[") && lastSegment.EndsWith("]"))
        {
            int indexStart = lastSegment.IndexOf("[");
            string propertyName = lastSegment.Substring(0, indexStart);
            int arrayIndex = int.Parse(lastSegment.Substring(indexStart + 1, lastSegment.Length - indexStart - 2));
            
            if (current[propertyName] == null)
            {
                current[propertyName] = new JArray();
            }
            
            var array = (JArray)current[propertyName]!;
            while (array.Count <= arrayIndex)
            {
                array.Add(null!);
            }
            
            array[arrayIndex] = value;
        }
        else
        {
            current[lastSegment] = value;
        }
    }

    private static string[] SplitJsonPath(string path)
    {
        var segments = new List<string>();
        int startIndex = 0;
        bool inBracket = false;
        
        for (int i = 0; i < path.Length; i++)
        {
            char c = path[i];
            
            if (c == '[')
            {
                inBracket = true;
            }
            else if (c == ']')
            {
                inBracket = false;
            }
            else if (c == '.' && !inBracket)
            {
                segments.Add(path.Substring(startIndex, i - startIndex));
                startIndex = i + 1;
            }
        }
        
        segments.Add(path.Substring(startIndex));
        return segments.ToArray();
    }
}
